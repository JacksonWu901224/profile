<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../css/styles.css">
        <link rel="icon" href="../photo/cardano.png">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
        <title>Blog</title>
    </head>
    <body>
        <header><h2>Blog</h2></header>
        <section>
            <div class="blog">
                <br>
                <span style="text-decoration: underline;">In general, <span style="color:blue">hash table</span></span> (Suppose that the size of the hash table is much adequately larger than the maximum number of possible entries. Therefore, very few data collision occurs.)
                <span style="text-decoration: underline;">is the most commonly used one for constructing a symbol table of a compiler.</span>
                <br>
                Memoization是一種優化技術,透過將函式執行後的結果暫存起來(快取)，當下次再次以相同參數呼叫時,就能直接從快取中提取結果,而無需重新計算,藉此提升程式執行速度。
                <hr>
                    <img src="../photo/pagetabletlb.png" width="70%">
                <hr>
                <h2 style="text-align:center;">Multilevel paging: 假設每個 page table 剛好佔一個 page</h2>
                <h3 style="text-align:center;text-decoration: underline;">「每個 page table 剛好佔一個 page」的設計，使得記憶體配置、位址切割、硬體查表與效能實作都能保持規則、對齊、且高效。</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                            <th>原因</th>
                            <th>說明</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                            <td><strong>1️⃣ 管理方便</strong></td>
                            <td>作業系統配置實體記憶體時以「頁 (page)」為最小單位。若每個頁表剛好佔一頁，則建立、釋放與置換都能以整頁為單位進行，管理簡單且不浪費空間。</td>
                            </tr>
                            <tr>
                            <td><strong>2️⃣ 位址切割整齊</strong></td>
                            <td>若每頁表剛好一頁，則「每層索引 bits」=log₂(頁內可放的表項數)。這讓虛擬位址可整齊分為：<br/>‧ 第1層索引 bits<br/>‧ 第2層索引 bits<br/>‧ offset bits</td>
                            </tr>
                            <tr>
                            <td><strong>3️⃣ 查表邏輯簡化</strong></td>
                            <td>每層頁表的每個表項剛好對應下一層page table的一個「整頁起始位址」。硬體 (MMU) 查表時不需考慮跨頁問題。</td>
                            </tr>
                            <tr>
                            <td><strong>4️⃣ 對齊整潔 (alignment)</strong></td>
                            <td>所有page table都與實體記憶體的frame邊界對齊，運算中只需簡單位元偏移計算。</td>
                            </tr>
                            <tr>
                            <td><strong>5️⃣ 效能與硬體實作簡化</strong></td>
                            <td>若page table可跨頁，硬體必須處理跨page邊界，邏輯與記憶體取用會更複雜、速度更慢。</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <br>
                <div class="table-container">
                    <table>
                        <thead>
                        <tr>
                            <th>狀況</th>
                            <th>是否要查 Page Table(主記憶體)</th>
                            <th>是否要取資料(主記憶體)</th>
                            <th>總次數</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>TLB hit + cache hit</td>
                            <td style="color:red;">❌</td>
                            <td style="color:red;">❌</td>
                            <td>0 次主記憶體存取(全cache命中)</td>
                        </tr>
                        <tr>
                            <td>TLB hit + cache miss</td>
                            <td style="color:red;">❌</td>
                            <td style="color:green;">✅</td>
                            <td>1 次(從 memory 取資料)</td>
                        </tr>
                        <tr>
                            <td>TLB miss + cache hit</td>
                            <td style="color:green;">✅</td>
                            <td style="color:red;">❌</td>
                            <td>1 次(查 page table)</td>
                        </tr>
                        <tr>
                            <td>TLB miss + cache miss</td>
                            <td style="color:green;">✅</td>
                            <td style="color:green;">✅</td>
                            <td>2 次(最糟情況)</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
                <br>
                <br>
                <div class="table-container">
                    <table> 
                        <thead>
                            <tr>
                                <th>類型</th>
                                <th>觸發來源</th>
                                <th>性質</th>
                                <th>目的</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Interrupt(中斷)</strong></td>
                                <td>由 <strong>硬體裝置</strong> 或 <strong>外部事件</strong> 觸發</td>
                                <td><strong>非同步 (asynchronous)</strong></td>
                                <td>告訴 CPU 某件外部事件需要立即處理，如鍵盤輸入、磁碟 I/O 完成</td>
                            </tr>
                            <tr>
                                <td><strong>Trap(陷阱) / System Call(系統呼叫)</strong></td>
                                <td>由 <strong>使用者程式</strong> 主動執行軟體指令觸發</td>
                                <td><strong>同步 (synchronous)</strong></td>
                                <td>讓使用者程式請求作業系統服務(如開檔、寫檔、分配記憶體)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                    <br>
                    <div style="display: inline-block; font-family: Arial, sans-serif; line-height: 1.3; border: 2px solid #333; padding: 15px; border-radius: 8px; 
                    background-color: #f9f9f9; width: fit-content;">
                        <p><strong>Interrupt</strong> ──► 硬體事件觸發 → 進入核心處理 → 回到使用者程式</p>
                        <p><strong>Trap</strong> ──► 軟體事件觸發 → 進入核心處理 → 回到使用者程式</p>
                        <p>└── <strong>System Call</strong> = 使用者主動呼叫作業系統服務的 Trap</p>
                    </div>
                    <br>
                    <br>
                    <div style="display: inline-block; text-align: left; font-size: 15px;border: 2px solid #333;border-radius: 8px;background-color: #f9f9f9; line-height: 1;
                                padding: 10px; ">
                        <div style="font-weight: 900; font-size: 20px; color: red">trap or interrupt flow :</div> 
                        <p style="font-weight: bold;">1.事件發生 (trap or interrupt issued)</p> 
                        → 當使用者程式執行異常、發出系統呼叫 (trap)，或外部裝置產生中斷 (interrupt) 時，會觸發此流程。 
                        <p style="font-weight: bold;">2.控制權轉移 (control transfer)</p> 
                        CPU 透過中斷向量表 (Interrupt Vector Table) 或陷阱向量表 (Trap Vector)，跳轉到作業系統對應的中斷／陷阱服務常式 (Service Routine)。
                        <p style="font-weight: bold;">3.模式切換 (mode bit switch)</p> 
                        &#9679; CPU 將模式位元 (Mode Bit) 設為 <span style="color:green">Kernel Mode</span>。<br> 
                        &#9679; 系統進入核心模式後, CPU 可存取所有受保護的資源與硬體。 
                        <p style="font-weight: bold;">4.執行服務程式 (Interrupt/Trap Service Routine)</p>
                        &#9679; Service routine是作業系統的一部分。<br>
                        &#9679; 核心根據中斷號碼或陷阱代號 (Trap ID) 判斷是何種事件並執行對應的服務。
                        <p style="font-weight: bold;">5.保存與恢復狀態 (Save and Restore Context)</p>
                        &#9679; 核心會先儲存當前的 CPU 狀態（暫存器、程式計數器等），以便事件處理結束後能恢復原執行狀態。<br>
                        &#9679; 事件處理完成後，核心會將先前保存的狀態恢復。
                        <p style="font-weight: bold;">6.執行相應的服務或例外處理 (Service or Exception Handling)</p>
                        &#9679; 若為系統呼叫 → 執行對應的核心服務。<br>
                        &#9679; 若為硬體中斷 → 讀取裝置狀態或完成 I/O 處理。<br>
                        &#9679; 若為例外 (Exception) → 採取錯誤處理機制（例如除以零錯誤、記憶體違例等）。
                        <p style="font-weight: bold;">7.返回使用者程式 (Return to User Program)</p>
                        &#9679; 處理完成後，控制權傳回被中斷或陷阱發生前的程式位置。<br>
                        &#9679; CPU 模式切回 <span style="color:green">User Mode</span>,恢復正常程式執行。<br> 
                        <br>
                        <div style="font-weight: 900; font-size: 20px; color: blue">system call flow :</div>
                        <p style="font-weight: bold;">1.使用者程式發出 <span style="color:red">Trap</span> 指令(issue a trap)</p>
                        → 用來「呼叫 (invoke)」系統呼叫。
                        <p style="font-weight: bold;">2.控制權轉移 (control transfer)</p>
                        CPU 透過 Interrupt Vector 或 System Call Vector,跳轉至作業系統對應的 Service Routine(服務常式)。
                        <p style="font-weight: bold;">3.模式切換 (mode bit switch)</p>
                        &#9679; CPU 將 Mode Bit 設為 <span style="color:green">Kernel Mode</span>。<br>
                        &#9679; 現在 CPU 擁有完整的系統資源存取權限。
                        <p style="font-weight: bold;">4.執行系統呼叫服務程式 (System Call Service Routine)</p>
                        &#9679; Service routine 是作業系統的一部分。<br>
                        &#9679; Kernel 檢查the interrupting instruction(or System Call ID) to determine what system call has occured.
                        <p style="font-weight: bold;">5.解析與檢查參數 (Parameter Passing)</p>
                        &#9679; 系統呼叫參數 (system call parameters) 說明使用者想請求的服務。<br>
                        &#9679; 參數傳遞方式可能有: registers, stack, memory(以指標傳遞給核心)
                        <p style="font-weight: bold;">6.kernel檢查請求是否合法</p>
                        &#9679; 若參數正確 → 執行請求的服務。<br>
                        &#9679; 若不合法 → 傳回錯誤碼給使用者程式。(例如「Permission Denied」或「Invalid Argument」)
                        <p style="font-weight: bold;">7.完成服務後返回</p>
                        &#9679; kernel完成系統呼叫的動作後, 將控制權 (control) 傳回到「系統呼叫指令的下一條指令」。<br>
                        &#9679; 模式切回 <span style="color:green">User Mode</span>,繼續執行使用者程式。
                    </div>
                    <hr>
                        <h3>The comparison-based sorting algorithm on n data requires \(&Omega;(nlogn)\) time</h3>
                        <h3>\(f(n)\)為polynomial-bounded\(\iff\) \(logf(n)=O(logn)\)</h3>
                        <h3>\(log(n!)=&Theta;(nlogn)\)</h3>
                        <h3>\(H(n)=1+1/2+1/3+1/4+...+1/n,&forall; n \in \mathbb{Z}^{+} , H(n)=&Theta;(logn)\)</h3>
                    <hr>
                        <h3>Methods of Proof:  \(\text{direct method, contrapositive method}(P \implies Q \equiv \neg Q \implies \neg P \equiv \neg P \lor Q) \text{and contradiction method(反證法)}\)</h3>
                        <h3>Open interval: \( \{ x \mid a < x < b \} \), 以\(\left( a,b \right)\)表示之, a ○───────○ b</h3>
                        <h3>Closed interval: \( \{ x \mid a \le x \le b \} \), 以\(\left[ a,b \right]\)表示之,  a ●───────● b</h3>
                        <h3>Cantor's Theorem:For two arbitrary <span style="color: blue">infinitely countable</span> sets A and B, both \(2^A\) and \(2^B\) are <span style="color: blue">uncountable</span>.</h3>
                        <h2 style="text-align:center;">Truth Table</h2>
                        <div class="table-container">
                            <table>
                                <thead>
                                <tr>
                                    <th>P</th>
                                    <th>Q</th>
                                    <th>Conjunction AND P&and;Q</th>
                                    <th>Disjunction OR P&or;Q</th>
                                    <th>Negation NOT ~P</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>T</td>
                                    <td>T</td>
                                    <td>T</td>
                                    <td>T</td>
                                    <td>F</td>
                                </tr>
                                <tr>
                                    <td>T</td>
                                    <td>F</td>
                                    <td>F</td>
                                    <td>T</td>
                                    <td>F</td>
                                </tr>
                                <tr>
                                    <td>F</td>
                                    <td>T</td>
                                    <td>F</td>
                                    <td>T</td>
                                    <td>T</td>
                                </tr>
                                <tr>
                                    <td>F</td>
                                    <td>F</td>
                                    <td>F</td>
                                    <td>F</td>
                                    <td>T</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                        <span style="white-space: pre;"><h3>           (a)onto                               (b)one-to-one                      (c)one-to-one且onto</h3></span>
                        <img src="../photo/Surjection_Injection_Bijection-fr.svg">
                        <span style="display: inline-block; text-align: left;white-space: pre;"><h3>(a)\(onto: \forall \text{y} \in \text{Y}, &exist; \text{x} \in \text{X } \text{s.t.} \text{ f(x)=y}\)          (b)\(1-1: f(x_1)=f(x_2) \implies x_1=x_2\)</h3></span>
                    <hr>
                        <h4>Different types of distances used in ML</h4>
                        <p><b>Minkowski distance:</b></p>
                        <div>\[
                        \left( \sum_{i=1}^{n} |x_i - y_i|^p \right)^{\frac{1}{p}}
                        \]</div>

                        <p><b>Euclidean distance:</b> (Minkowski distance → p is 2)</p>
                        <div>\[
                        \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}
                        \]</div>

                        <p><b>Manhattan distance:</b> (Minkowski distance->p is 1)</p>
                        <div>\[
                        \sum_{i=1}^{n} |x_i - y_i|
                        \]</div>

                        <p><b>Chebyshev distance:</b> (Minkowski distance->p is &infin;)</p>
                        <div>\[
                        \lim_{p\to\infty} \left( \sum_{i=1}^{n} |x_i - y_i|^p \right)^{\frac{1}{p}}=\max_i |x_i - y_i|
                        \]</div>

                        <p><b>Hamming distance:</b></p>
                        <div>\[
                        \sum_{i=1}^{n} [x_i \neq y_i]
                        \]</div>
                    <hr>
                        <h4>scalability interoperability sustainability</h4>
                    <hr>
                    <div class="table-container">
                        <table>
                            <thead>
                            <tr>
                                <th>類型</th>
                                <th>圖的性質</th>
                                <th>主要演算法</th>
                                <th>找到的東西</th>
                                <th>時間複雜度</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td><strong>SCC(Strongly Connected Components)</strong></td>
                                <td><strong>有向圖 (Directed Graph)</strong></td>
                                <td><strong>Kosaraju's Algorithm</strong>、<strong>Tarjan's SCC Algorithm</strong></td>
                                <td>強連通分量</td>
                                <td class="mono">O(V + E)</td>
                            </tr>
                            <tr>
                                <td><strong>BCC(Biconnected Components)</strong></td>
                                <td><strong>無向圖 (Undirected Graph)</strong></td>
                                <td><strong>Tarjan's BCC Algorithm</strong></td>
                                <td>雙連通分量(邊或點)</td>
                                <td class="mono">O(V + E)</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                    <hr>
                        <img src="../photo/fibonacciheap.png" width="65%">
                    <hr>
                        <div style="display: inline-block; text-align: left;">
                            基本上這世界上的問題可以分類為：<br>
                            (1) Unsolvable Problem<br>
                            (2) Intractable Problem<br>
                            (3) NP-Problem<br>
                            (4) P-Problem
                        </div>
                        <h4>若\(\text{A}&le;_p\text{B}\), 則\(\text{B}\)為polynomial-time solvable \(\implies \) \(\text{A}\)為polynomial-time solvable</h4>
                        <h4>若\(&exist;\)一個\(\text{NP-complete}\)的問題為polynomial-time solvable, 則\(\text{P}&equals;\text{NP}\)</h4>
                        <div style="display: inline-block; text-align: left;">
                            <h4>P:\(A \in \text{P} \), \(\text{B}&le;_p\text{A}\), 則\(\text{B}\)為P</h4>
                            <h4>NP-hard:\( \forall A \in \text{NP} \), \(\text{A}&le;_p\text{B}\), 則\(\text{B}\)為NP-hard</h4>
                            <h4>NP-complete:若\(A \in \text{NP} \)且\(\text{A}\)為NP-hard, 則\(\text{A}\)為NP-complete</h4>
                        </div>
                        <br>
                        <span style="white-space: pre;"><h3>(a)若\(\text{P}&ne;\text{NP}\)                                                           (b)若\(\text{P}&equals;\text{NP}\)</h3></span>
                        <br>
                        <img src="../photo/P_np_np-complete_np-hard..png">
                        <h4><span style="color: blue">Any problem in P can be reduced to SAT in polynomial time.</span></h4>
                        <h4><span style="color: blue">If SAT has a polynomial time algorithm, then P =NP.</span></h4>
                        <h4><span style="color: blue">SAT is NP-complete.</span></h4>
            
                <div class="Karp21">
                    <img src="../photo/Karp21NPC.png" width="900">
                </div>
            <hr>
                <h2 style="text-align:center;">C/C++ operator precedence</h2>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>優先順序</th>
                            <th>運算子</th>
                            <th>關聯性</th>
                            <th>說明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>1</td><td>
                            <span class="op">()</span>
                            <span class="op">[]</span>
                            <span class="op">a->b</span>
                            <span class="op">a.b</span>
                            <span class="op">a++</span>
                            <span class="op">a--</span></td><td>左至右</td><td>括號、陣列、成員存取、遞增、遞減</td></tr>
                        <tr><td>2</td><td>
                            <span class="op">!a</span>、
                            <span class="op">~a</span>、
                            <span class="op">+a</span>
                            <span class="op">-a</span>、
                            <span class="op">*a</span>
                            <span class="op">&amp;a</span>、
                            <span class="op">(type)a</span>、
                            <span class="op">sizeof</span>
                        </td><td>右至左</td><td>邏輯非、位元非、正負號、指標解參考/取址、型態轉換、sizeof</td></tr>
                        <tr><td>3</td><td>
                            <span class="op">a*b</span>
                            <span class="op">a/b</span>
                            <span class="op">a%b</span>
                        </td><td>左至右</td><td>乘法、除法、餘數</td></tr>
                        <tr><td>4</td><td>
                            <span class="op">a+b</span>
                            <span class="op">a-b</span>
                        </td><td>左至右</td><td>加法、減法</td></tr>
                        <tr><td>5</td><td>
                            <span class="op">a&lt;&lt;b</span>
                            <span class="op">a&gt;&gt;b</span>
                        </td><td>左至右</td><td>左移、右移</td></tr>
                        <tr><td>6</td><td>
                            <span class="op">a&lt;b</span>
                            <span class="op">a&lt;=b</span>
                            <span class="op">a&gt;b</span>
                            <span class="op">a&gt;=b</span>
                        </td><td>左至右</td><td>小於、小於或等於、大於、大於或等於</td></tr>
                        <tr><td>7</td><td>
                            <span class="op">a==b</span>
                            <span class="op">a!=b</span>
                        </td><td>左至右</td><td>等於、不等於</td></tr>
                        <tr><td>8</td><td>
                            <span class="op">a&amp;b</span>
                        </td><td>左至右</td><td>bitwise AND</td></tr>
                        <tr><td>9</td><td>
                            <span class="op">a^b</span>
                        </td><td>左至右</td><td>bitwise XOR</td></tr>
                        <tr><td>10</td><td>
                            <span class="op">a|b</span>
                        </td><td>左至右</td><td>bitwise OR</td></tr>
                        <tr><td>11</td><td>
                            <span class="op">a&amp;&amp;b</span>
                        </td><td>左至右</td><td>logical AND</td></tr>
                        <tr><td>12</td><td>
                            <span class="op">a||b</span>
                        </td><td>左至右</td><td>logical OR</td></tr>
                        <tr><td>13</td><td>
                            <span class="op">a ? b : c</span>
                        </td><td>右至左</td><td>條件運算子</td></tr>
                        <tr><td>14</td><td>
                            <span class="op">a=b</span>
                            <span class="op">a+=b</span>
                            <span class="op">a-=b</span>
                            <span class="op">a*=b</span>
                            <span class="op">a/=b</span>
                            <span class="op">a%=b</span>
                            <span class="op">a&amp;=b</span>
                            <span class="op">a^=b</span>
                            <span class="op">a|=b</span>
                        </td><td>右至左</td><td>賦值、複合賦值</td></tr>
                        <tr><td>15</td><td>
                            <span class="op">a, b</span>
                        </td><td>左至右</td><td>逗號運算子</td></tr>
                    </tbody>
                </table>
            </div>
        </section>
    <script src="../javascript/script.js"></script>
    </body>
</html>